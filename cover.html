
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>handlers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">test-task-ozon/internal/pkg/handlers/converter.pb.go (56.2%)</option>
				
				<option value="file1">test-task-ozon/internal/pkg/handlers/converter_grpc.pb.go (62.5%)</option>
				
				<option value="file2">test-task-ozon/internal/pkg/handlers/create_url.go (82.6%)</option>
				
				<option value="file3">test-task-ozon/internal/pkg/handlers/get_url.go (0.0%)</option>
				
				<option value="file4">test-task-ozon/internal/pkg/handlers/server_grpc.go (96.0%)</option>
				
				<option value="file5">test-task-ozon/internal/pkg/repository/links/in_memory_link.go (100.0%)</option>
				
				<option value="file6">test-task-ozon/internal/pkg/repository/links/postgres_link.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.25.0-devel
//         protoc        v3.14.0
// source: converter.proto

package handlers

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type RequestGetLink struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ShortenUrl string `protobuf:"bytes,1,opt,name=shorten_url,json=shortenUrl,proto3" json:"shorten_url,omitempty"`
}

func (x *RequestGetLink) Reset() <span class="cov8" title="1">{
        *x = RequestGetLink{}
        if protoimpl.UnsafeEnabled </span><span class="cov8" title="1">{
                mi := &amp;file_converter_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RequestGetLink) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RequestGetLink) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RequestGetLink) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_converter_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RequestGetLink.ProtoReflect.Descriptor instead.
func (*RequestGetLink) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_converter_proto_rawDescGZIP(), []int{0}
}</span>

func (x *RequestGetLink) GetShortenUrl() string <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.ShortenUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ResponseGetLink struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        InitialUrl string `protobuf:"bytes,1,opt,name=initial_url,json=initialUrl,proto3" json:"initial_url,omitempty"`
}

func (x *ResponseGetLink) Reset() <span class="cov8" title="1">{
        *x = ResponseGetLink{}
        if protoimpl.UnsafeEnabled </span><span class="cov8" title="1">{
                mi := &amp;file_converter_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ResponseGetLink) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ResponseGetLink) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ResponseGetLink) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_converter_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ResponseGetLink.ProtoReflect.Descriptor instead.
func (*ResponseGetLink) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_converter_proto_rawDescGZIP(), []int{1}
}</span>

func (x *ResponseGetLink) GetInitialUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.InitialUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RequestGeneration struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        InitialUrl string `protobuf:"bytes,1,opt,name=initial_url,json=initialUrl,proto3" json:"initial_url,omitempty"`
}

func (x *RequestGeneration) Reset() <span class="cov8" title="1">{
        *x = RequestGeneration{}
        if protoimpl.UnsafeEnabled </span><span class="cov8" title="1">{
                mi := &amp;file_converter_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RequestGeneration) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RequestGeneration) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RequestGeneration) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_converter_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RequestGeneration.ProtoReflect.Descriptor instead.
func (*RequestGeneration) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_converter_proto_rawDescGZIP(), []int{2}
}</span>

func (x *RequestGeneration) GetInitialUrl() string <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.InitialUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ResponseGeneration struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ShortenUrl string `protobuf:"bytes,1,opt,name=shorten_url,json=shortenUrl,proto3" json:"shorten_url,omitempty"`
}

func (x *ResponseGeneration) Reset() <span class="cov8" title="1">{
        *x = ResponseGeneration{}
        if protoimpl.UnsafeEnabled </span><span class="cov8" title="1">{
                mi := &amp;file_converter_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ResponseGeneration) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ResponseGeneration) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ResponseGeneration) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_converter_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ResponseGeneration.ProtoReflect.Descriptor instead.
func (*ResponseGeneration) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_converter_proto_rawDescGZIP(), []int{3}
}</span>

func (x *ResponseGeneration) GetShortenUrl() string <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.ShortenUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_converter_proto protoreflect.FileDescriptor

var file_converter_proto_rawDesc = []byte{
        0x0a, 0x0f, 0x63, 0x6f, 0x6e, 0x76, 0x65, 0x72, 0x74, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x12, 0x04, 0x6d, 0x61, 0x69, 0x6e, 0x22, 0x31, 0x0a, 0x0e, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x47, 0x65, 0x74, 0x4c, 0x69, 0x6e, 0x6b, 0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x68, 0x6f,
        0x72, 0x74, 0x65, 0x6e, 0x5f, 0x75, 0x72, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a,
        0x73, 0x68, 0x6f, 0x72, 0x74, 0x65, 0x6e, 0x55, 0x72, 0x6c, 0x22, 0x32, 0x0a, 0x0f, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x47, 0x65, 0x74, 0x4c, 0x69, 0x6e, 0x6b, 0x12, 0x1f, 0x0a,
        0x0b, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x6c, 0x5f, 0x75, 0x72, 0x6c, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x0a, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x6c, 0x55, 0x72, 0x6c, 0x22, 0x34,
        0x0a, 0x11, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x12, 0x1f, 0x0a, 0x0b, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x6c, 0x5f, 0x75,
        0x72, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61,
        0x6c, 0x55, 0x72, 0x6c, 0x22, 0x35, 0x0a, 0x12, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x68,
        0x6f, 0x72, 0x74, 0x65, 0x6e, 0x5f, 0x75, 0x72, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x0a, 0x73, 0x68, 0x6f, 0x72, 0x74, 0x65, 0x6e, 0x55, 0x72, 0x6c, 0x32, 0x8f, 0x01, 0x0a, 0x10,
        0x43, 0x6f, 0x6e, 0x76, 0x65, 0x72, 0x74, 0x65, 0x72, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
        0x12, 0x38, 0x0a, 0x07, 0x47, 0x65, 0x74, 0x4c, 0x69, 0x6e, 0x6b, 0x12, 0x14, 0x2e, 0x6d, 0x61,
        0x69, 0x6e, 0x2e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x47, 0x65, 0x74, 0x4c, 0x69, 0x6e,
        0x6b, 0x1a, 0x15, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x47, 0x65, 0x74, 0x4c, 0x69, 0x6e, 0x6b, 0x22, 0x00, 0x12, 0x41, 0x0a, 0x0a, 0x47, 0x65,
        0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x17, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
        0x6e, 0x1a, 0x18, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x00, 0x42, 0x0d, 0x5a,
        0x0b, 0x2e, 0x2f, 0x3b, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x73, 0x62, 0x06, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_converter_proto_rawDescOnce sync.Once
        file_converter_proto_rawDescData = file_converter_proto_rawDesc
)

func file_converter_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_converter_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_converter_proto_rawDescData = protoimpl.X.CompressGZIP(file_converter_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_converter_proto_rawDescData</span>
}

var file_converter_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_converter_proto_goTypes = []interface{}{
        (*RequestGetLink)(nil),     // 0: main.RequestGetLink
        (*ResponseGetLink)(nil),    // 1: main.ResponseGetLink
        (*RequestGeneration)(nil),  // 2: main.RequestGeneration
        (*ResponseGeneration)(nil), // 3: main.ResponseGeneration
}
var file_converter_proto_depIdxs = []int32{
        0, // 0: main.ConverterService.GetLink:input_type -&gt; main.RequestGetLink
        2, // 1: main.ConverterService.Generation:input_type -&gt; main.RequestGeneration
        1, // 2: main.ConverterService.GetLink:output_type -&gt; main.ResponseGetLink
        3, // 3: main.ConverterService.Generation:output_type -&gt; main.ResponseGeneration
        2, // [2:4] is the sub-list for method output_type
        0, // [0:2] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_converter_proto_init() }</span>
func file_converter_proto_init() <span class="cov8" title="1">{
        if File_converter_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_converter_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RequestGetLink); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_converter_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ResponseGetLink); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_converter_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RequestGeneration); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_converter_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ResponseGeneration); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_converter_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   4,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_converter_proto_goTypes,
                DependencyIndexes: file_converter_proto_depIdxs,
                MessageInfos:      file_converter_proto_msgTypes,
        }.Build()
        File_converter_proto = out.File
        file_converter_proto_rawDesc = nil
        file_converter_proto_goTypes = nil
        file_converter_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package handlers

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ConverterServiceClient is the client API for ConverterService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConverterServiceClient interface {
        GetLink(ctx context.Context, in *RequestGetLink, opts ...grpc.CallOption) (*ResponseGetLink, error)
        Generation(ctx context.Context, in *RequestGeneration, opts ...grpc.CallOption) (*ResponseGeneration, error)
}

type converterServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewConverterServiceClient(cc grpc.ClientConnInterface) ConverterServiceClient <span class="cov8" title="1">{
        return &amp;converterServiceClient{cc}
}</span>

func (c *converterServiceClient) GetLink(ctx context.Context, in *RequestGetLink, opts ...grpc.CallOption) (*ResponseGetLink, error) <span class="cov8" title="1">{
        out := new(ResponseGetLink)
        err := c.cc.Invoke(ctx, "/main.ConverterService/GetLink", in, out, opts...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *converterServiceClient) Generation(ctx context.Context, in *RequestGeneration, opts ...grpc.CallOption) (*ResponseGeneration, error) <span class="cov8" title="1">{
        out := new(ResponseGeneration)
        err := c.cc.Invoke(ctx, "/main.ConverterService/Generation", in, out, opts...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// ConverterServiceServer is the server API for ConverterService service.
// All implementations must embed UnimplementedConverterServiceServer
// for forward compatibility
type ConverterServiceServer interface {
        GetLink(context.Context, *RequestGetLink) (*ResponseGetLink, error)
        Generation(context.Context, *RequestGeneration) (*ResponseGeneration, error)
        mustEmbedUnimplementedConverterServiceServer()
}

// UnimplementedConverterServiceServer must be embedded to have forward compatible implementations.
type UnimplementedConverterServiceServer struct {
}

func (UnimplementedConverterServiceServer) GetLink(context.Context, *RequestGetLink) (*ResponseGetLink, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetLink not implemented")
}</span>
func (UnimplementedConverterServiceServer) Generation(context.Context, *RequestGeneration) (*ResponseGeneration, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Generation not implemented")
}</span>
func (UnimplementedConverterServiceServer) mustEmbedUnimplementedConverterServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeConverterServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConverterServiceServer will
// result in compilation errors.
type UnsafeConverterServiceServer interface {
        mustEmbedUnimplementedConverterServiceServer()
}

func RegisterConverterServiceServer(s grpc.ServiceRegistrar, srv ConverterServiceServer) <span class="cov8" title="1">{
        s.RegisterService(&amp;ConverterService_ServiceDesc, srv)
}</span>

func _ConverterService_GetLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(RequestGetLink)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov8" title="1">{
                return srv.(ConverterServiceServer).GetLink(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/main.ConverterService/GetLink",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ConverterServiceServer).GetLink(ctx, req.(*RequestGetLink))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ConverterService_Generation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(RequestGeneration)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov8" title="1">{
                return srv.(ConverterServiceServer).Generation(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/main.ConverterService/Generation",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ConverterServiceServer).Generation(ctx, req.(*RequestGeneration))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// ConverterService_ServiceDesc is the grpc.ServiceDesc for ConverterService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConverterService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "main.ConverterService",
        HandlerType: (*ConverterServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetLink",
                        Handler:    _ConverterService_GetLink_Handler,
                },
                {
                        MethodName: "Generation",
                        Handler:    _ConverterService_Generation_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "converter.proto",
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        "net/http"
        "test-task-ozon/internal/pkg/repository/links"
)

const (
        prefixURL = "localhost:8080/"
)

func (h *LinksHandler) Generation(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        decoder := json.NewDecoder(r.Body)
        link := new(links.Links)
        err := decoder.Decode(&amp;link)
        if err != nil </span><span class="cov8" title="1">{
                h.Logger.Infof("url:%s method:%s error: failed to decrypt during generation - %s", r.URL.Path, r.Method, err.Error())
                http.Error(w, `generation failed`, http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">opts := []grpc.DialOption{
                grpc.WithTransportCredentials(insecure.NewCredentials()),
        }
        conn, err := grpc.Dial("localhost:9879", opts...)
        if err != nil </span><span class="cov0" title="0">{
                h.Logger.Infof("url:%s method:%s error: failed to connect to localhost:9879 - %s", r.URL.Path, r.Method, err.Error())
                http.Error(w, `generation failed`, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">defer conn.Close()
        client := NewConverterServiceClient(conn)

        res, err := client.Generation(context.Background(), &amp;RequestGeneration{
                InitialUrl: link.InitialURL,
        })
        if err != nil </span><span class="cov8" title="1">{
                h.Logger.Infof("url:%s method:%s error: generation failed - %s", r.URL.Path, r.Method, err.Error())
                http.Error(w, `generation failed`, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">err = h.Send.Sending(w, r, res.GetShortenUrl())
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "context"
        "github.com/gorilla/mux"
        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/status"
        "net/http"
        "test-task-ozon/internal/pkg/repository/links"
        "test-task-ozon/internal/pkg/sendingjson"
)

type LinksHandler struct {
        LinkRepo links.LinkRepo
        Logger   *zap.SugaredLogger
        Send     sendingjson.ServiceSend
}

func (h *LinksHandler) GetLink(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        opts := []grpc.DialOption{
                grpc.WithTransportCredentials(insecure.NewCredentials()),
        }
        conn, err := grpc.Dial("localhost:9879", opts...)
        if err != nil </span><span class="cov0" title="0">{
                h.Logger.Infof("url:%s method:%s error: failed to connect to localhost:9879 - %s", r.URL.Path, r.Method, err.Error())
                http.Error(w, `generation failed`, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">defer conn.Close()
        client := NewConverterServiceClient(conn)

        res, err := client.GetLink(context.Background(), &amp;RequestGetLink{
                ShortenUrl: vars["URL"],
        })
        if status.Code(err) == codes.NotFound </span><span class="cov0" title="0">{
                h.Logger.Infof("url:%s method:%s error: failed to get link - %v", r.URL.Path, r.Method, err)
                http.Error(w, `this link was not found`, http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                h.Logger.Infof("url:%s method:%s error: failed to get link - %v", r.URL.Path, r.Method, err)
                http.Error(w, `couldn't get the original link`, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">err = h.Send.Sending(w, r, res.GetInitialUrl())
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "context"
        "database/sql"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "log"
        "net"
        "test-task-ozon/internal/pkg/repository/links"
        "test-task-ozon/internal/pkg/urlgeneration"
)

type ConverterServer struct {
        LinkRepo links.LinkRepo
        UnimplementedConverterServiceServer
}

func (c ConverterServer) GetLink(_ context.Context, requestLink *RequestGetLink) (*ResponseGetLink, error) <span class="cov8" title="1">{
        link, err := c.LinkRepo.GetInitialLink(requestLink.GetShortenUrl())
        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, status.Error(codes.NotFound, err.Error())
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;ResponseGetLink{
                InitialUrl: link.InitialURL,
        }, nil</span>
}

func (c ConverterServer) Generation(_ context.Context, requestGeneration *RequestGeneration) (*ResponseGeneration, error) <span class="cov8" title="1">{
        link := new(links.Links)
        link.InitialURL = requestGeneration.GetInitialUrl()
        existingURL, err := c.LinkRepo.GetShortenLink(link.InitialURL)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if existingURL != nil </span><span class="cov8" title="1">{
                link.ShortenURL = existingURL.ShortenURL
        }</span> else<span class="cov8" title="1"> {
                link.ShortenURL = urlgeneration.GenerationURL()
                err = c.LinkRepo.AddLink(link)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">finalLink := prefixURL + link.ShortenURL
        return &amp;ResponseGeneration{
                ShortenUrl: finalLink,
        }, nil</span>
}

func StartConverterServer(linkRepo links.LinkRepo) <span class="cov8" title="1">{
        lis, err := net.Listen("tcp", "localhost:9879")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to listen: %v", err)
        }</span>
        <span class="cov8" title="1">grpcServer := grpc.NewServer()
        RegisterConverterServiceServer(grpcServer, &amp;ConverterServer{
                LinkRepo: linkRepo,
        })
        grpcServer.Serve(lis)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package links

import (
        "database/sql"
        "sync"
)

type RepoLinkInMemory struct {
        links map[string]*Links
        mu    *sync.RWMutex
}

func NewRepoLinkInMemory() (*RepoLinkInMemory, error) <span class="cov8" title="1">{
        return &amp;RepoLinkInMemory{
                links: make(map[string]*Links, 0),
                mu:    &amp;sync.RWMutex{},
        }, nil
}</span>

func (lm *RepoLinkInMemory) AddLink(item *Links) error <span class="cov8" title="1">{
        lm.mu.Lock()
        lm.links[item.ShortenURL] = item
        lm.mu.Unlock()
        return nil
}</span>

func (lm *RepoLinkInMemory) GetInitialLink(url string) (*Links, error) <span class="cov8" title="1">{
        lm.mu.RLock()
        link, existence := lm.links[url]
        lm.mu.RUnlock()
        if existence </span><span class="cov8" title="1">{
                return link, nil
        }</span>
        <span class="cov8" title="1">return nil, sql.ErrNoRows</span>
}

func (lm *RepoLinkInMemory) GetShortenLink(url string) (*Links, error) <span class="cov8" title="1">{
        lm.mu.RLock()
        for _, initialLink := range lm.links </span><span class="cov8" title="1">{
                if initialLink.InitialURL == url </span><span class="cov8" title="1">{
                        lm.mu.RUnlock()
                        return initialLink, nil
                }</span>
        }
        <span class="cov8" title="1">lm.mu.RUnlock()
        return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package links

import (
        "context"
        "database/sql"
)

type RepoLinkPostgres struct {
        Ctx context.Context
        DB  *sql.DB
}

func NewRepoLinkPostgres(db *sql.DB, ctx context.Context) (*RepoLinkPostgres, error) <span class="cov8" title="1">{
        return &amp;RepoLinkPostgres{
                DB:  db,
                Ctx: ctx,
        }, nil

}</span>

func (lm *RepoLinkPostgres) AddLink(item *Links) error <span class="cov8" title="1">{
        _, err := lm.DB.ExecContext(lm.Ctx, "INSERT INTO link VALUES ($1,$2);", item.InitialURL, item.ShortenURL)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (lm *RepoLinkPostgres) GetInitialLink(url string) (*Links, error) <span class="cov8" title="1">{
        row := lm.DB.QueryRowContext(lm.Ctx, "SELECT initial_url,shorten_url FROM link WHERE shorten_url=$1 LIMIT 1;", url)
        link := new(Links)
        err := row.Scan(&amp;link.InitialURL, &amp;link.ShortenURL)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return link, nil</span>
}

func (lm *RepoLinkPostgres) GetShortenLink(url string) (*Links, error) <span class="cov8" title="1">{
        row := lm.DB.QueryRowContext(lm.Ctx, "SELECT initial_url,shorten_url FROM link WHERE initial_url=$1 LIMIT 1;", url)
        link := new(Links)
        err := row.Scan(&amp;link.InitialURL, &amp;link.ShortenURL)
        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return link, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
